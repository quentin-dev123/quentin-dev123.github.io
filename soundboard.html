<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Soundboard</title>
  <style>
    :root {
      color-scheme: light dark;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    body {
      margin: 0;
      min-height: 100vh;
      padding: 1.5rem;
      background: canvas;
      color: canvastext;
    }
    main {
      max-width: 900px;
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
    }
    header {
      text-align: center;
    }
    form {
      display: grid;
      gap: 0.9rem;
      padding: 1rem;
      border-radius: 0.9rem;
      background: color-mix(in srgb, canvastext 8%, canvas);
      border: 1px solid color-mix(in srgb, canvastext 12%, canvas);
    }
    label {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
      font-size: 0.95rem;
    }
    input[type="text"],
    input[type="file"] {
      padding: 0.6rem;
      border-radius: 0.6rem;
      border: 1px solid color-mix(in srgb, canvastext 25%, canvas);
      background: canvas;
      color: inherit;
    }
    input[type="file"] {
      padding: 0.35rem;
    }
    button {
      cursor: pointer;
      border: none;
      border-radius: 0.7rem;
      padding: 0.75rem 1rem;
      font-weight: 600;
      color: white;
      background: #1f73ff;
      transition: opacity 0.2s;
    }
    button:hover {
      opacity: 0.9;
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      align-items: center;
      justify-content: space-between;
      font-size: 0.9rem;
    }
    .controls button {
      background: #e03232;
    }
    .sound-list {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }
    .sound-card {
      padding: 1rem;
      border-radius: 1rem;
      border: 1px solid color-mix(in srgb, canvastext 15%, canvas);
      background: color-mix(in srgb, canvastext 6%, canvas);
      display: flex;
      flex-direction: column;
      gap: 0.9rem;
    }
    .sound-card h3 {
      margin: 0;
      font-size: 1.1rem;
    }
    .sound-actions {
      display: flex;
      gap: 0.75rem;
      flex-wrap: wrap;
    }
    .sound-actions button {
      flex: 1 1 120px;
      min-width: 120px;
    }
    .progress-row {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      flex-wrap: wrap;
    }
    .progress-row input[type="range"] {
      flex: 1 1 auto;
      min-width: 180px;
    }
    .time-label {
      font-variant-numeric: tabular-nums;
      font-size: 0.9rem;
      color: color-mix(in srgb, canvastext 70%, canvas);
    }
    .empty-state {
      padding: 2rem;
      text-align: center;
      border-radius: 1rem;
      border: 1px dashed color-mix(in srgb, canvastext 25%, canvas);
      color: color-mix(in srgb, canvastext 70%, canvas);
    }
    .meta {
      font-size: 0.85rem;
      color: color-mix(in srgb, canvastext 70%, canvas);
    }
  </style>
</head>
<body>
  <main>
    <header>
      <h1>Soundboard</h1>
      <p>Add short sound effects and control playback precisely.</p>
    </header>

    <form id="sound-form">
      <label>
        Title
        <input id="title" type="text" placeholder="e.g., Airhorn" required />
      </label>
      <label>
        Sound file
        <input id="file" type="file" accept="audio/*" required />
      </label>
      <button type="submit">Add sound</button>
    </form>

    <section class="controls">
      <span id="storage-stats" class="meta">Total stored: 0 KB</span>
      <button type="button" id="clear-btn">Clear all</button>
    </section>

    <section id="empty-state" class="empty-state">
      No sounds yet. Add your first clip above!
    </section>

    <section id="sound-list" class="sound-list" hidden></section>
  </main>

  <script>
    const STORAGE_KEY = "soundboard-meta";
    const DB_NAME = "SoundboardDB";
    const STORE_NAME = "sounds";
    let db;
    const controllers = new Map();

    const form = document.getElementById("sound-form");
    const titleInput = document.getElementById("title");
    const fileInput = document.getElementById("file");
    const soundList = document.getElementById("sound-list");
    const emptyState = document.getElementById("empty-state");
    const storageStats = document.getElementById("storage-stats");
    const clearBtn = document.getElementById("clear-btn");

    init();

    async function init() {
      db = await openDB();
      renderSounds();
    }

    form.addEventListener("submit", async (event) => {
      event.preventDefault();
      const title = titleInput.value.trim();
      const file = fileInput.files[0];
      if (!title || !file) return;

      const id = crypto.randomUUID();
      await saveBlob(id, file);

      const meta = loadMeta();
      meta.push({
        id,
        title,
        type: file.type,
        size: file.size,
        addedAt: Date.now()
      });
      saveMeta(meta);

      form.reset();
      renderSounds();
    });

    clearBtn.addEventListener("click", async () => {
      if (!confirm("Delete all stored sounds? This cannot be undone.")) return;
      await clearStore();
      saveMeta([]);
      controllers.forEach((ctrl) => {
        ctrl.audio?.pause();
        if (ctrl.url) URL.revokeObjectURL(ctrl.url);
      });
      controllers.clear();
      renderSounds();
    });

    async function renderSounds() {
      const meta = loadMeta();
      updateStats(meta);
      soundList.innerHTML = "";

      if (!meta.length) {
        emptyState.hidden = false;
        soundList.hidden = true;
        return;
      }

      emptyState.hidden = true;
      soundList.hidden = false;

      meta.forEach((item) => {
        const card = createSoundCard(item);
        soundList.appendChild(card);
      });
    }

    function createSoundCard({ id, title, size }) {
      const card = document.createElement("article");
      card.className = "sound-card";
      card.dataset.id = id;

      const heading = document.createElement("h3");
      heading.textContent = title;

      const actions = document.createElement("div");
      actions.className = "sound-actions";

      const playBtn = document.createElement("button");
      playBtn.type = "button";
      playBtn.textContent = "Play";
      playBtn.addEventListener("click", () => togglePlay(id));

      const restartBtn = document.createElement("button");
      restartBtn.type = "button";
      restartBtn.textContent = "Restart";
      restartBtn.addEventListener("click", () => restartSound(id));

      actions.append(playBtn, restartBtn);

      const progressRow = document.createElement("div");
      progressRow.className = "progress-row";

      const progress = document.createElement("input");
      progress.type = "range";
      progress.min = 0;
      progress.max = 100;
      progress.value = 0;
      progress.step = 0.1;
      progress.disabled = true;
      progress.addEventListener("input", () => seekSound(id, progress.value));

      const timeLabel = document.createElement("span");
      timeLabel.className = "time-label";
      timeLabel.textContent = "0:00 / 0:00";

      progressRow.append(progress, timeLabel);

      const sizeLabel = document.createElement("span");
      sizeLabel.className = "meta";
      sizeLabel.textContent = `Size: ${(size / 1024).toFixed(1)} KB`;

      card.append(heading, actions, progressRow, sizeLabel);

      controllers.set(id, {
        id,
        playBtn,
        restartBtn,
        progress,
        timeLabel,
        isLoading: false,
        audio: null,
        url: null
      });

      return card;
    }

    async function ensureAudio(id) {
      const ctrl = controllers.get(id);
      if (!ctrl) throw new Error("Controller missing");

      if (ctrl.audio) return ctrl.audio;

      if (ctrl.isLoading) {
        return new Promise((resolve) => {
          const interval = setInterval(() => {
            if (ctrl.audio) {
              clearInterval(interval);
              resolve(ctrl.audio);
            }
          }, 50);
        });
      }

      ctrl.isLoading = true;
      ctrl.playBtn.textContent = "Loadingâ€¦";
      ctrl.playBtn.disabled = true;
      ctrl.restartBtn.disabled = true;

      try {
        const blob = await getBlob(id);
        if (!blob) throw new Error("Audio data missing");
        const url = URL.createObjectURL(blob);
        const audio = new Audio(url);

        const updateUI = () => updateProgressUI(id);
        audio.addEventListener("timeupdate", updateUI);
        audio.addEventListener("durationchange", updateUI);
        audio.addEventListener("ended", () => {
          audio.pause();
          audio.currentTime = audio.duration || 0;
          updateProgressUI(id);
          setPlayLabel(id, false);
        });

        ctrl.audio = audio;
        ctrl.url = url;
        ctrl.progress.disabled = false;
        ctrl.playBtn.disabled = false;
        ctrl.restartBtn.disabled = false;
        setPlayLabel(id, false);
        updateProgressUI(id);
        return audio;
      } finally {
        ctrl.isLoading = false;
      }
    }

    async function togglePlay(id) {
      const audio = await ensureAudio(id);
      const isPlaying = !audio.paused;
      if (isPlaying) {
        audio.pause();
        setPlayLabel(id, false);
      } else {
        pauseOthers(id);
        await audio.play();
        setPlayLabel(id, true);
      }
    }

    async function restartSound(id) {
      const audio = await ensureAudio(id);
      audio.pause();
      audio.currentTime = 0;
      updateProgressUI(id);
      setPlayLabel(id, false);
    }

    async function seekSound(id, percent) {
      const audio = await ensureAudio(id);
      if (!audio.duration || audio.duration === Infinity) return;
      const nextTime = (percent / 100) * audio.duration;
      audio.currentTime = nextTime;
      updateProgressUI(id);
    }

    function pauseOthers(exceptId) {
      controllers.forEach((ctrl, id) => {
        if (id === exceptId) return;
        if (ctrl.audio && !ctrl.audio.paused) {
          ctrl.audio.pause();
          setPlayLabel(id, false);
        }
      });
    }

    function setPlayLabel(id, isPlaying) {
      const ctrl = controllers.get(id);
      if (!ctrl) return;
      ctrl.playBtn.textContent = isPlaying ? "Pause" : "Play";
    }

    function updateProgressUI(id) {
      const ctrl = controllers.get(id);
      if (!ctrl || !ctrl.audio) return;
      const { audio, progress, timeLabel } = ctrl;

      const duration = audio.duration && isFinite(audio.duration) ? audio.duration : 0;
      const current = audio.currentTime || 0;
      const percent = duration ? (current / duration) * 100 : 0;

      progress.value = percent;
      timeLabel.textContent = `${formatTime(current)} / ${duration ? formatTime(duration) : "0:00"}`;
    }

    function formatTime(seconds) {
      if (!isFinite(seconds)) return "0:00";
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60)
        .toString()
        .padStart(2, "0");
      return `${mins}:${secs}`;
    }

    function loadMeta() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        return raw ? JSON.parse(raw) : [];
      } catch {
        return [];
      }
    }

    function saveMeta(meta) {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(meta));
    }

    function updateStats(meta) {
      const totalBytes = meta.reduce((sum, item) => sum + (item.size || 0), 0);
      const kb = totalBytes / 1024;
      storageStats.textContent = `Total stored: ${
        kb >= 1024 ? (kb / 1024).toFixed(2) + " MB" : kb.toFixed(1) + " KB"
      } (${meta.length} item${meta.length === 1 ? "" : "s"})`;
    }

    function openDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, 1);
        request.onerror = () => reject(request.error);
        request.onupgradeneeded = () => {
          const database = request.result;
          if (!database.objectStoreNames.contains(STORE_NAME)) {
            database.createObjectStore(STORE_NAME, { keyPath: "id" });
          }
        };
        request.onsuccess = () => resolve(request.result);
      });
    }

    function saveBlob(id, file) {
      return new Promise((resolve, reject) => {
        const tx = db.transaction(STORE_NAME, "readwrite");
        const store = tx.objectStore(STORE_NAME);
        const entry = { id, blob: file };
        const request = store.put(entry);
        request.onsuccess = () => resolve();
        request.onerror = () => reject(request.error);
      });
    }

    function getBlob(id) {
      return new Promise((resolve, reject) => {
        const tx = db.transaction(STORE_NAME, "readonly");
        const store = tx.objectStore(STORE_NAME);
        const request = store.get(id);
        request.onsuccess = () => resolve(request.result ? request.result.blob : null);
        request.onerror = () => reject(request.error);
      });
    }

    function clearStore() {
      return new Promise((resolve, reject) => {
        const tx = db.transaction(STORE_NAME, "readwrite");
        const store = tx.objectStore(STORE_NAME);
        const request = store.clear();
        request.onsuccess = () => resolve();
        request.onerror = () => reject(request.error);
      });
    }
  </script>
</body>
</html>
